//
// Created by Le Minh Cristian on 2021/10/29.
//

#ifndef QUANFLOQ_TYPEINFO_HPP
#define QUANFLOQ_TYPEINFO_HPP

#include "RegistrarConcepts.hpp"
#include "SharedRegistrar.hpp"
#include "ObjectRegistrar.hpp"
#include <typeindex>
#include <string>
#include <memory>
#include <filesystem>

// region Overrides
namespace QuanFloq {
	struct TypeInfo;
}
template<>
struct std::less<QuanFloq::TypeInfo> : std::less<std::type_index> {
	using is_transparent = void;
	using std::less<std::type_index>::operator();
	bool operator()( const QuanFloq::TypeInfo& lhs, const QuanFloq::TypeInfo& rhs ) const;
	bool operator()( const QuanFloq::TypeInfo& lhs, const std::type_index& rhs ) const;
	bool operator()( const std::type_index& lhs, const QuanFloq::TypeInfo& rhs ) const;
};
template<>
struct std::equal_to<QuanFloq::TypeInfo> : std::equal_to<std::type_index>, std::equal_to<std::string_view> {
	using is_transparent = void;
	using std::equal_to<std::type_index>::operator();
	using std::equal_to<std::string_view>::operator();
	bool operator()( const QuanFloq::TypeInfo& lhs, const QuanFloq::TypeInfo& rhs ) const;
	bool operator()( const QuanFloq::TypeInfo& lhs, const std::type_index& rhs ) const;
	bool operator()( const std::type_index& lhs, const QuanFloq::TypeInfo& rhs ) const;
	bool operator()( const QuanFloq::TypeInfo& lhs, std::string_view rhs ) const;
	bool operator()( std::string_view lhs, const QuanFloq::TypeInfo& rhs ) const;
};
template<>
struct std::hash<QuanFloq::TypeInfo> : std::hash<std::type_index> {
	using is_transparent = void;
	using std::hash<std::type_index>::operator();
	// TODO: Switch to a string_view hasher and type_index demangle
	size_t operator()( const QuanFloq::TypeInfo& val ) const;
};
// endregion

namespace QuanFloq {
	// Forward Declarations
	struct BaseFactory;
	struct BaseTypeTraits;

	// region Main classes
	struct dynamic_library {
		using registrar_type = SharedRegistrarRoot<dynamic_library>;
		inline static registrar_type registrar;
		[[nodiscard]] static std::shared_ptr<dynamic_library> Create( std::string_view libray );

		static void* OpenDL( const std::filesystem::path& location );
		static void CloseDL( void* ptr );
		const std::filesystem::path Location;
		void* const DLL;
	private:
		explicit dynamic_library( std::string_view library );
	public:
		~dynamic_library();

	public:
		std::string_view GetName() const;
		bool operator==( const dynamic_library& t2 ) const;
	};

	struct TypeInfo {
		using registrar_type = ObjectRegistrarRoot<TypeInfo>;
		using task_type = registrar_type::task_type<std::type_index>;
		using awaiter_type = registrar_type::awaiter_type<std::type_index>;
		inline static registrar_type registrar;
		const std::type_index type;
		mutable std::string name;
		const std::string mangledName;
		mutable std::shared_ptr<dynamic_library> library;
		BaseFactory* factory;
		IRegistrar* iRegistrar;
		static const TypeInfo& Create( BaseTypeTraits&& data );
		template<class T>
		static const TypeInfo& Create();
		template<class T>
		static const TypeInfo& Create( std::string_view name );
		template<class T, class Base>
		static const TypeInfo& Create( std::string_view suffix );
		static task_type AddSuffix( const TypeInfo& type, const std::type_index& base, std::string_view suffix );
		// TODO: More Create interface for Non-autogenerated data
		explicit TypeInfo( BaseTypeTraits&& data );

	public:
		std::string_view GetName() const;
		bool operator==( const TypeInfo& t2 ) const;
		bool operator==( const std::type_index& t2 ) const;
	};
	// endregion
	// region Helper classes
	struct BaseTypeTraits {
		const std::type_index type;
		virtual std::string_view Name() = 0;
		std::string_view MangledName() const;
		virtual BaseFactory* Factory() = 0;
		virtual IRegistrar* Registrar() = 0;
	protected:
		explicit BaseTypeTraits( const std::type_index& type );
	};
	template<class T>
	struct TypeTraits :
			BaseTypeTraits {
		std::string name;
		std::string_view Name() override;
		BaseFactory* Factory() override;
		IRegistrar* Registrar() override;
		TypeTraits();
		explicit TypeTraits( std::string_view name );
	};
	// endregion
}

#endif //QUANFLOQ_TYPEINFO_HPP
