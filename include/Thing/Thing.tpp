//
// Created by lecris on 2021-11-15.
//

#ifndef QUANFLOQ_THINGTHING_TPP
#define QUANFLOQ_THINGTHING_TPP

#include "Thing.hpp"
#include "ThingDef.hpp"
#include "Registrar/TypeInfo.tpp"
#include "Registrar/Factory.tpp"
#include "interface/Scriber/Scriber.tpp"

using namespace QuanFloq;

// region Constructor/Destructor
template<class T>
ThingBase<T>::ThingBase( std::shared_ptr<BaseDef> def ) :
		BaseThing(def) { }
template<class Traits>
Thing_<Traits>::Thing_( std::shared_ptr<def_type> def ) :
		base(def), def{*def} {
	static_assert(std::derived_from<thing_type, alias>,
	              "Traits::thing_type does not derive Thing<Traits>");
	if constexpr (!std::same_as<interface_type, void>)
			static_assert(std::derived_from<thing_type, interface_type>,
			              "Traits::thing_type does not derive Traits::interface_type");
}
// endregion

// region Static initializations
template<class Traits>
inline const TypeInfo* const Thing_<Traits>::typeInfo = &TypeInfo::Create<thing_type>();
// endregion

// region Interfaces
template<class Traits>
void Thing_<Traits>::ExposeData( Scriber& scriber ) {
	BaseThing::ExposeData(scriber);
	data = dynamic_cast<data_type*>(BaseThing::data.get());
	for (auto& comp: BaseThing::comps) {
		auto comp2 = dynamic_cast<comp_type*>(comp.get());
		if (comp2 != nullptr)
			comps.push_back(comp2);
	}
	if constexpr(stdSharedRegistrar<thing_type>)
		thing_type::registrar.ResolvePostRegister(this->GetName());
}
template<class Traits>
std::unique_ptr<typename Traits::thing_type> ThingFactory_<Traits>::Make( IExposable* parent ) {
	std::unique_ptr<thing_type> ptr;
	// TODO: Currently the comps are not generated by default, they need to be created by ExposeData.
	//  What is the purpose of CompDefs in the Def?
	if constexpr(std::same_as<driver_type, void>) {
		static_assert(std::constructible_from<thing_type, std::shared_ptr<def_type>>,
		              "Thing is not standard constructible");
		ptr = std::make_unique<thing_type>(def);
	} else {
		static_assert(std::constructible_from<thing_type, std::shared_ptr<def_type>, std::shared_ptr<driver_type>>,
		              "Thing is not standard constructible");
		auto driver = std::dynamic_pointer_cast<driver_type>(def->driver);
		assert(driver);
		ptr = std::make_unique<thing_type>(def, driver);
	}
	if (def->scriberDriver != nullptr)
		ptr->format = def->scriberDriver;
	return ptr;
}
template<class Traits>
ThingFactory_<Traits>::ThingFactory_() {
	this->name.clear();
}
// endregion

#include "ThingDriver.tpp"
#include "IThing.tpp"
#include "ThingCache.tpp"
#include "ThingData.tpp"
#include "ThingDef.tpp"
#include "ThingComp.tpp"

#endif //QUANFLOQ_THINGTHING_TPP
